// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates fuzzing_test.go. It can be invoked by running
// go generate
package main

import (
	"log"
	"math/rand"
	"os"
	"strings"
	"text/template"
	"time"
	"unicode"
)

var stringCases []string = []string{
	"SnakeCase", "UpperSnakeCase", "KebabCase", "UpperKebabCase", "CamelCase", "UpperCamelCase"}

func wordsToCase(words []string, stringCase string) string {
	for i, _ := range words {
		if stringCase == "UpperSnakeCase" || stringCase == "UpperKebabCase" {
			words[i] = strings.ToUpper(words[i])
		} else {
			words[i] = strings.ToLower(words[i])
		}
		if stringCase == "UpperCamelCase" || stringCase == "CamelCase" && i > 0 {
			words[i] = strings.Title(words[i])
		}
	}
	var delimiter string
	if stringCase == "SnakeCase" || stringCase == "UpperSnakeCase" {
		delimiter = "_"
	} else if stringCase == "KebabCase" || stringCase == "UpperKebabCase" {
		delimiter = "-"
	} else {
		delimiter = ""
	}
	return strings.Join(words, delimiter)
}

var delimiters = []rune(`?!.,'"/\|[]{}<>()-=*&^%$#@` + " \n\t\r")

func randomJoin(words []string) string {
	var builder strings.Builder
	idx := 0
	shouldCapitalizeNextWord := false
	addedDelimiter := false
	for idx < len(words) {
		word := words[idx]
		firstIsLetter := true
		allLetters := true
		for i, ch := range word {
			if unicode.IsDigit(ch) {
				allLetters = false
				if i == 0 {
					firstIsLetter = false
				}
			}
		}

		coinToss := rand.Float32()
		if coinToss < 0.3 {
			// No delimiter
		} else if coinToss < 0.6 || (!firstIsLetter && !addedDelimiter) {
			// Add delimiter
			builder.WriteRune(delimiters[rand.Intn(len(delimiters))])
			shouldCapitalizeNextWord = false
			addedDelimiter = true
		} else {
			// Add word
			var targetStr string
			if shouldCapitalizeNextWord {
				targetStr = strings.Title(word)
			} else {
				possibleActions := []func(string) string{
					strings.ToLower,
				}
				if firstIsLetter {
					possibleActions = append(possibleActions, strings.Title)
				}
				if allLetters {
					possibleActions = append(possibleActions, strings.ToUpper)
				}
				targetStr = possibleActions[rand.Intn(len(possibleActions))](word)
			}
			builder.WriteString(targetStr)
			idx += 1
			shouldCapitalizeNextWord = true
			addedDelimiter = false
		}
	}
	return builder.String()
}

var alphabetRunes = []rune("abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщьыъэюя0123456789")

func randomWord(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = alphabetRunes[rand.Intn(len(alphabetRunes))]
	}
	return string(b)
}

func randomWords(numWords int, minWordLen int, maxWordLen int) []string {
	words := make([]string, 0, numWords)
	for i := 0; i < numWords; i++ {
		wordLen := rand.Intn(maxWordLen - minWordLen + 1) + minWordLen
		words = append(words, randomWord(wordLen))
	}
	return words
}

type testCase struct {
	Function		string
	Input			string
	ExpectedOutput	string
}

type data struct {
	Timestamp	time.Time
	Seed		int64
	TestCases	[]testCase
}

const numRandomTestCases = 1000
const minWordLen = 2
const maxWordLen = 5
const numWords = 10

func main() {
	seed := int64(42)
	rand.Seed(seed)

	f, err := os.Create("fuzzing_test.go")
	die(err)
	defer f.Close()

	testCases := make([]testCase, numRandomTestCases)
	for i := 0; i < numRandomTestCases; i++ {
		words := randomWords(numWords, minWordLen, maxWordLen)
		targetCase := stringCases[rand.Intn(len(stringCases))]
		testCases[i] = testCase{
			Function:       targetCase,
			Input:          randomJoin(words),
			ExpectedOutput: wordsToCase(words, targetCase),
		}
	}

	err = packageTemplate.Execute(f, data{
		Timestamp:		time.Now(),
		Seed:			seed,
		TestCases:		testCases,
	})
	die(err)
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using seed {{ .Seed }}.
package casify

import (
	"testing"
	"github.com/stretchr/testify/assert"
)

func TestFuzzing(t *testing.T) {
{{- range .TestCases }}
	assert.Equal(t, {{ .Function }}({{ printf "%q" .Input }}), {{ printf "%q" .ExpectedOutput }})
{{- end }}
}
`))